# Clawshake v3.1 Spec — Competitive Feature Parity + Differentiation

**Context**: v3 is live with 47 tests. These additions close every gap identified in competitor analysis. Implement in order.

---

## 1. CCTP Cross-Chain Settlement (HIGH PRIORITY)

Competitors Rose Protocol, Abdiel, and FloClaw all use Circle's CCTP. We need this to show deep Circle integration.

### New contract: `contracts/CrossChainShake.sol`

Uses Circle's CCTP (Cross-Chain Transfer Protocol) to enable recursive hire chains that span multiple chains.

**Core concept**: Parent shake on Base, child shake on Polygon/Ethereum. USDC burns on source chain, mints on destination chain via CCTP attestation.

**Functions**:
- `createCrossChainShake(uint256 parentShakeId, uint256 amount, uint32 destinationDomain, bytes32 mintRecipient, uint48 deadline, bytes32 taskHash) → bytes32 cctpNonce` — Burns USDC on Base via CCTP's TokenMessenger, creates a pending cross-chain child shake
- `confirmCrossChainShake(uint256 shakeId, bytes calldata cctpAttestation)` — Confirms USDC minted on destination chain
- `getDestinationDomain(string chain) → uint32` — Maps chain names to CCTP domain IDs

**CCTP Integration**:
- Import Circle's `ITokenMessenger` interface (depositForBurn)
- Import `IMessageTransmitter` interface (receiveMessage)
- Base Sepolia CCTP domain: 6
- TokenMessenger address on Base Sepolia: `0x9f3B8679c73C2Fef8b59B4f3444d4e156fb70AA5`
- USDC on Base Sepolia: `0x036CbD53842c5426634e7929541eC2318f3dCF7e`

**Struct addition to ShakeEscrow**:
```solidity
struct CrossChainInfo {
    uint32 destinationDomain;
    bytes32 mintRecipient;
    uint64 cctpNonce;
    bool confirmed;
}
mapping(uint256 => CrossChainInfo) public crossChainShakes;
```

**Events**:
```solidity
event CrossChainShakeCreated(uint256 indexed shakeId, uint32 destinationDomain, uint64 cctpNonce);
event CrossChainShakeConfirmed(uint256 indexed shakeId);
```

### Tests:
- `it("creates cross-chain child shake and burns USDC via CCTP")`
- `it("confirms cross-chain shake with attestation")`
- `it("prevents release of parent until cross-chain child settles")`
- `it("maps correct CCTP domain IDs")`

---

## 2. ERC-4626 Vault Yield on Idle Escrow (HIGH PRIORITY)

wren_ai built an ERC-4626 vault. We go further: escrowed USDC earns yield WHILE locked.

### New contract: `contracts/YieldEscrow.sol`

Wraps ShakeEscrow so that locked USDC is deposited into an ERC-4626 vault (e.g., Aave, Compound, or a mock vault for testnet). When the shake releases, it withdraws from the vault — worker gets principal + their share of yield.

**Functions**:
- `depositToVault(uint256 shakeId)` — Deposits a shake's escrowed USDC into the yield vault. Can be called by anyone (protocol, requester, or automatically).
- `withdrawFromVault(uint256 shakeId) → uint256 totalWithdrawn` — Withdraws principal + accrued yield. Called internally by releaseShake.
- `getAccruedYield(uint256 shakeId) → uint256` — View function showing yield earned so far.
- `setVault(address vaultAddress)` — Treasury sets the ERC-4626 vault address.

**Yield Distribution**:
- 80% of yield → worker (incentive to deliver fast... but also rewarded for longer complex tasks)
- 15% of yield → requester (reward for locking capital)
- 5% of yield → protocol treasury

**Integration**: Modify `releaseShake()` in ShakeEscrow to call `withdrawFromVault()` first if funds are deposited.

### New contract: `contracts/MockVault.sol`
Simple ERC-4626 mock vault for testing. Simulates 5% APY. Implements `deposit()`, `withdraw()`, `convertToAssets()`, `convertToShares()`.

### Tests:
- `it("deposits escrowed USDC into vault")`
- `it("accrues yield over time")`
- `it("distributes yield correctly on release: 80/15/5")`
- `it("withdraws correctly even if vault has losses")`
- `it("works with recursive chains — each child's escrow earns independently")`

---

## 3. Encrypted Deliverables (MEDIUM PRIORITY)

opcbme/BME encrypts deliverables so the requester can't grab work without paying. We need this.

### Changes to `contracts/ShakeEscrow.sol`:

**New fields in Shake struct**:
```solidity
bytes32 requesterPubKeyHash;   // Hash of requester's encryption public key (set at createShake)
bytes32 encryptedDeliveryKey;  // Encrypted symmetric key (only requester can decrypt after release)
```

**Flow**:
1. `createShake()` — Requester includes `requesterPubKeyHash` (hash of their X25519 public key)
2. Worker encrypts deliverable with a random symmetric key, uploads to IPFS
3. `deliverShake()` — Worker submits `deliveryHash` (encrypted IPFS CID) + `encryptedDeliveryKey` (symmetric key encrypted with requester's public key)
4. `releaseShake()` — Requester can now decrypt the symmetric key → decrypt deliverable from IPFS
5. Before release, requester sees only the encrypted blob — can't grab-and-run

**New function**:
- `createShakeEncrypted(uint256 amount, uint48 deadline, bytes32 taskHash, bytes32 requesterPubKeyHash)` — Same as createShake but with pubkey hash
- `deliverShakeEncrypted(uint256 shakeId, bytes32 deliveryHash, bytes32 encryptedDeliveryKey)` — Same as deliverShake but includes encrypted key

**Backward compatible**: Original `createShake()` and `deliverShake()` still work (requesterPubKeyHash defaults to 0, meaning unencrypted).

### Tests:
- `it("creates encrypted shake with pubkey hash")`
- `it("delivers with encrypted delivery key")`
- `it("encrypted delivery key only accessible after release")`
- `it("backward compatible — unencrypted shakes still work")`

---

## 4. Agent Discovery Search (MEDIUM PRIORITY)

Multiple competitors have agent search/DNS. Our AgentRegistry has skills but no search.

### Changes to `contracts/AgentRegistry.sol`:

**New functions**:
- `searchBySkill(string calldata skill) → address[]` — Returns all agents with a matching skill
- `getTopAgents(uint256 count) → address[]` — Returns top agents by success rate (min 5 shakes)
- `getAgentsByMinRating(uint256 minSuccessRate) → address[]` — Filter by reputation

**New mapping**:
```solidity
mapping(bytes32 => address[]) public skillIndex;  // keccak256(skill) -> agents
```

**Update `register()`** to populate `skillIndex` for each skill.

### New file: `server/discovery.js` (add to existing x402 server)

REST endpoints:
- `GET /agents/search?skill=scraping&minRating=9000` — Search agents by skill + min reputation
- `GET /agents/top?count=10` — Top agents by reputation
- `GET /agents/:address/compatibility?taskSkills=scraping,analysis` — Skill match score

### Tests:
- `it("finds agents by skill")`
- `it("returns top agents by success rate")`
- `it("filters by minimum rating")`
- `it("skill index updates on registration")`

---

## 5. MIND x402 Protocol Spec + MIC IR (BONUS)

Define the x402 payment protocol in pure MindLang, compile to MIC IR. Shows MIND handles real protocols beyond math.

### New file: `mind/src/x402.mind`

```mind
// x402 Payment Protocol — MindLang Specification
// Defines request/response types for HTTP 402 agent-to-agent payments

struct X402Request {
    method: str,
    path: str,
    headers: Map<str, str>,
    body: Bytes,
}

struct X402Response {
    status: u16,          // 402 for payment required
    payment_address: Address,
    payment_amount: u256,
    payment_chain: str,
    payment_protocol: str,  // "clawshake/v1"
    shake_id: Option<u256>,
}

struct PaymentProof {
    tx_hash: str,
    chain_id: u64,
    block_number: u64,
    shake_id: u256,
}

fn handle_request(req: X402Request, escrow: &EscrowClient) -> X402Response {
    // Route to appropriate handler
    // Return 402 with payment details if auth required
    // Return 200 with data if payment confirmed
}
```

### Compile to MIC IR: `mind/ir/x402.mic`

---

## TODO — Execution Order

1. [ ] **CCTP Cross-Chain** — `contracts/CrossChainShake.sol` + CCTP interface + tests
2. [ ] **ERC-4626 Vault Yield** — `contracts/YieldEscrow.sol` + `contracts/MockVault.sol` + tests
3. [ ] **Encrypted Deliverables** — Modify ShakeEscrow + tests
4. [ ] **Agent Discovery** — Modify AgentRegistry + server endpoint + tests
5. [ ] **MIND x402 Spec** — `mind/src/x402.mind` + `mind/ir/x402.mic`
6. [ ] **All tests pass** — `npx hardhat test` all green
7. [ ] **Git push** — `git commit -m "v3.1: CCTP, vault yield, encrypted deliverables, agent search, MIND x402" && git push`

### Run with:
```bash
cd /home/n/clawshake
# In Claude Code CLI session:
# "Read V3.1_SPEC.md and implement all items in order. Read the existing contracts first to understand the codebase."
```
