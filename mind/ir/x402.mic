; Clawshake — x402 HTTP Payment Protocol (MIC IR)
; Copyright (c) 2026 STARGA, Inc. All rights reserved.
;
; Mind Intermediate Code (MIC) representation of x402.mind
; Generated by: mind --emit-ir src/x402.mind
;
; MIC is the lowered representation of MIND source. It sits between
; high-level MIND syntax and the target backend (WASM, native, EVM).
; Each MIC opcode maps to a deterministic sequence of backend instructions.
;
; Notation:
;   %N         = SSA register (static single assignment)
;   @name      = global symbol reference
;   $T         = type reference
;   const.T V  = typed constant literal
;   alloc.T    = stack allocation of type T
;   load.T     = load value from pointer
;   store.T    = store value to pointer
;   call       = direct function call
;   br         = unconditional branch
;   br_if      = conditional branch
;   ret        = function return
;   phi        = SSA phi node (merge point)
;   gep        = get element pointer (struct field access)

; ============================================================================
; MODULE DECLARATION
; ============================================================================

module @x402 {

; ============================================================================
; TYPE DEFINITIONS
; ============================================================================

; struct X402Request { method: str, path: str, headers: Map<str,str>, body: Vec<u8> }
type $X402Request = { str, str, $Map_str_str, $Vec_u8 }

; struct X402Response { status: u16, payment_address: $Address, payment_amount: u256,
;                       payment_chain: str, payment_protocol: str, shake_id: $Option_u256,
;                       headers: $Map_str_str, body: $Vec_u8 }
type $X402Response = { u16, $Address, u256, str, str, $Option_u256, $Map_str_str, $Vec_u8 }

; struct PaymentProof { tx_hash: str, chain_id: u64, block_number: u64, shake_id: u256 }
type $PaymentProof = { str, u64, u64, u256 }

; struct X402Server { escrow: $EscrowClient, registry: $RegistryClient, config: $ShakeConfig,
;                     payment_address: $Address, default_amount: u256,
;                     chain_name: str, protocol_version: str }
type $X402Server = { $EscrowClient, $RegistryClient, $ShakeConfig, $Address, u256, str, str }

; struct X402Client { base_url: str, chain_id: u64, signer: $PrivateKey }
type $X402Client = { str, u64, $PrivateKey }

; enum X402Route — discriminated union, tag byte + payload
;   0 = GetShake { shake_id: u256 }
;   1 = PostShake
;   2 = GetAgent { agent_address: $Address }
;   3 = ListJobs
;   4 = Health
;   5 = NotFound
type $X402Route = { u8, [u8; 32] }

; External type references (defined in other MIC modules)
type $Address = extern @types::Address
type $EscrowClient = extern @escrow::EscrowClient
type $RegistryClient = extern @registry::RegistryClient
type $ShakeConfig = extern @types::ShakeConfig
type $PrivateKey = extern @crypto::PrivateKey
type $MicOp = extern @mic::MicOp
type $MicResult = extern @mic::MicResult
type $Map_str_str = { ptr, u64 }          ; hash map internal: (bucket_ptr, len)
type $Vec_u8 = { ptr, u64, u64 }          ; (data_ptr, len, cap)
type $Option_u256 = { u8, u256 }          ; (tag: 0=None/1=Some, value)

; ============================================================================
; FUNCTION: X402Request::new
; Allocates and initializes an X402Request on the stack.
; ============================================================================

fn @X402Request_new(%0: ptr, %1: ptr) -> $X402Request {
entry:
  %2 = alloc.X402Request
  %3 = call @str_clone(%0)                ; clone method string
  %4 = gep %2, 0                          ; &req.method
  store.str %3, %4
  %5 = call @str_clone(%1)                ; clone path string
  %6 = gep %2, 1                          ; &req.path
  store.str %5, %6
  %7 = call @Map_str_str_new()            ; empty header map
  %8 = gep %2, 2                          ; &req.headers
  store.Map_str_str %7, %8
  %9 = call @Vec_u8_new()                 ; empty body
  %10 = gep %2, 3                         ; &req.body
  store.Vec_u8 %9, %10
  %11 = load.X402Request %2
  ret %11
}

; ============================================================================
; FUNCTION: X402Request::has_payment_proof
; Checks if X-Payment-Proof header is present.
; ============================================================================

fn @X402Request_has_payment_proof(%0: ptr) -> u8 {
entry:
  %1 = gep %0, 2                          ; &self.headers
  %2 = const.str "X-Payment-Proof"
  %3 = call @Map_str_str_contains_key(%1, %2)
  ret %3                                   ; 0 = false, 1 = true
}

; ============================================================================
; FUNCTION: X402Response::payment_required
; Constructs a 402 response with payment headers.
; ============================================================================

fn @X402Response_payment_required(%0: ptr, %1: u256, %2: ptr, %3: ptr) -> $X402Response {
  ; %0 = address: &Address
  ; %1 = amount: u256
  ; %2 = chain: &str
  ; %3 = protocol: &str
entry:
  %4 = alloc.X402Response
  %5 = const.u16 402
  %6 = gep %4, 0                          ; &resp.status
  store.u16 %5, %6
  %7 = load.Address %0
  %8 = gep %4, 1                          ; &resp.payment_address
  store.Address %7, %8
  %9 = gep %4, 2                          ; &resp.payment_amount
  store.u256 %1, %9
  %10 = call @str_clone(%2)
  %11 = gep %4, 3                         ; &resp.payment_chain
  store.str %10, %11
  %12 = call @str_clone(%3)
  %13 = gep %4, 4                         ; &resp.payment_protocol
  store.str %12, %13

  ; Build headers map with x402 fields
  %14 = call @Map_str_str_new()
  %15 = const.str "X-Payment-Required"
  %16 = const.str "true"
  call @Map_str_str_insert(%14, %15, %16)
  %17 = const.str "X-Payment-Address"
  %18 = call @Address_to_hex(%0)
  call @Map_str_str_insert(%14, %17, %18)
  %19 = const.str "X-Payment-Amount"
  %20 = call @u256_to_string(%1)
  call @Map_str_str_insert(%14, %19, %20)
  %21 = const.str "X-Payment-Chain"
  call @Map_str_str_insert(%14, %21, %10)
  %22 = const.str "X-Payment-Protocol"
  call @Map_str_str_insert(%14, %22, %12)

  %23 = gep %4, 6                         ; &resp.headers
  store.Map_str_str %14, %23

  ; Build JSON error body
  %24 = call @format_402_body(%0, %1, %2, %3)
  %25 = call @str_to_bytes(%24)
  %26 = gep %4, 7                         ; &resp.body
  store.Vec_u8 %25, %26

  ; shake_id = None
  %27 = gep %4, 5                         ; &resp.shake_id
  %28 = const.u8 0                        ; None tag
  store.u8 %28, %27

  %29 = load.X402Response %4
  ret %29
}

; ============================================================================
; FUNCTION: X402Response::ok
; Constructs a 200 response with the given body.
; ============================================================================

fn @X402Response_ok(%0: ptr, %1: u64) -> $X402Response {
  ; %0 = body data pointer
  ; %1 = body length
entry:
  %2 = alloc.X402Response
  %3 = const.u16 200
  %4 = gep %2, 0                          ; &resp.status
  store.u16 %3, %4
  %5 = call @Address_zero()
  %6 = gep %2, 1                          ; &resp.payment_address
  store.Address %5, %6
  %7 = const.u256 0
  %8 = gep %2, 2                          ; &resp.payment_amount
  store.u256 %7, %8
  %9 = const.str ""
  %10 = gep %2, 3                         ; &resp.payment_chain
  store.str %9, %10
  %11 = gep %2, 4                         ; &resp.payment_protocol
  store.str %9, %11
  %12 = gep %2, 5                         ; &resp.shake_id (None)
  %13 = const.u8 0
  store.u8 %13, %12
  %14 = call @Map_str_str_new()
  %15 = gep %2, 6                         ; &resp.headers
  store.Map_str_str %14, %15
  %16 = call @Vec_u8_from_raw(%0, %1)
  %17 = gep %2, 7                         ; &resp.body
  store.Vec_u8 %16, %17
  %18 = load.X402Response %2
  ret %18
}

; ============================================================================
; FUNCTION: X402Response::not_found
; ============================================================================

fn @X402Response_not_found() -> $X402Response {
entry:
  %0 = const.str "{\"error\":\"not_found\"}"
  %1 = call @str_to_bytes(%0)
  %2 = call @X402Response_ok(%1.ptr, %1.len)   ; reuse ok, then patch status
  %3 = gep %2, 0                               ; &resp.status
  %4 = const.u16 404
  store.u16 %4, %3
  ret %2
}

; ============================================================================
; FUNCTION: PaymentProof::new
; ============================================================================

fn @PaymentProof_new(%0: ptr, %1: u64, %2: u64, %3: u256) -> $PaymentProof {
  ; %0 = tx_hash: &str
  ; %1 = chain_id: u64
  ; %2 = block_number: u64
  ; %3 = shake_id: u256
entry:
  %4 = alloc.PaymentProof
  %5 = call @str_clone(%0)
  %6 = gep %4, 0                          ; &proof.tx_hash
  store.str %5, %6
  %7 = gep %4, 1                          ; &proof.chain_id
  store.u64 %1, %7
  %8 = gep %4, 2                          ; &proof.block_number
  store.u64 %2, %8
  %9 = gep %4, 3                          ; &proof.shake_id
  store.u256 %3, %9
  %10 = load.PaymentProof %4
  ret %10
}

; ============================================================================
; FUNCTION: PaymentProof::validate_tx_hash
; Validates that tx_hash is a 66-char hex string starting with "0x".
; ============================================================================

fn @PaymentProof_validate_tx_hash(%0: ptr) -> u8 {
entry:
  %1 = gep %0, 0                          ; &self.tx_hash
  %2 = load.str %1
  %3 = call @str_len(%2)
  %4 = const.u64 66
  %5 = icmp.ne %3, %4
  br_if %5, label @reject

  %6 = call @str_starts_with(%2, "0x")
  %7 = const.u8 0
  %8 = icmp.eq %6, %7
  br_if %8, label @reject

  ; Iterate chars [2..66] checking hex validity
  %9 = const.u64 2
  br label @loop_head

loop_head:
  %10 = phi [%9, entry], [%18, loop_body]
  %11 = icmp.ge %10, %3
  br_if %11, label @accept

loop_body:
  %12 = call @str_char_at(%2, %10)
  %13 = call @is_hex_char(%12)
  %14 = const.u8 0
  %15 = icmp.eq %13, %14
  br_if %15, label @reject
  %18 = add.u64 %10, 1
  br label @loop_head

accept:
  %16 = const.u8 1
  ret %16

reject:
  %17 = const.u8 0
  ret %17
}

; ============================================================================
; FUNCTION: parse_route
; Route dispatch: parses method + path into X402Route discriminated union.
; ============================================================================

fn @parse_route(%0: ptr, %1: ptr) -> $X402Route {
  ; %0 = method: &str
  ; %1 = path: &str
entry:
  %2 = alloc.X402Route
  %3 = call @str_eq(%0, "GET")
  br_if %3, label @route_get

  %4 = call @str_eq(%0, "POST")
  br_if %4, label @route_post

  br label @route_not_found

route_get:
  %5 = call @str_eq(%1, "/health")
  br_if %5, label @route_health

  %6 = call @str_eq(%1, "/v1/jobs")
  br_if %6, label @route_list_jobs

  %7 = call @str_starts_with(%1, "/v1/shake/")
  br_if %7, label @route_get_shake

  %8 = call @str_starts_with(%1, "/v1/agent/")
  br_if %8, label @route_get_agent

  br label @route_not_found

route_post:
  %9 = call @str_eq(%1, "/v1/shake")
  br_if %9, label @route_post_shake
  br label @route_not_found

route_health:
  %10 = const.u8 4                        ; Health tag
  %11 = gep %2, 0
  store.u8 %10, %11
  %12 = load.X402Route %2
  ret %12

route_list_jobs:
  %13 = const.u8 3                        ; ListJobs tag
  %14 = gep %2, 0
  store.u8 %13, %14
  %15 = load.X402Route %2
  ret %15

route_get_shake:
  %16 = const.u64 10                      ; len("/v1/shake/")
  %17 = call @str_substr(%1, %16)         ; extract ID substring
  %18 = call @parse_u256(%17)             ; parse shake_id
  %19 = const.u8 0                        ; GetShake tag
  %20 = gep %2, 0
  store.u8 %19, %20
  %21 = gep %2, 1                         ; payload: shake_id
  store.u256 %18, %21
  %22 = load.X402Route %2
  ret %22

route_get_agent:
  %23 = const.u64 10                      ; len("/v1/agent/")
  %24 = call @str_substr(%1, %23)         ; extract address substring
  %25 = call @Address_from_hex(%24)       ; parse Address
  %26 = const.u8 2                        ; GetAgent tag
  %27 = gep %2, 0
  store.u8 %26, %27
  %28 = gep %2, 1                         ; payload: agent_address
  store.Address %25, %28
  %29 = load.X402Route %2
  ret %29

route_post_shake:
  %30 = const.u8 1                        ; PostShake tag
  %31 = gep %2, 0
  store.u8 %30, %31
  %32 = load.X402Route %2
  ret %32

route_not_found:
  %33 = const.u8 5                        ; NotFound tag
  %34 = gep %2, 0
  store.u8 %33, %34
  %35 = load.X402Route %2
  ret %35
}

; ============================================================================
; FUNCTION: X402Server::handle_request
; Top-level request dispatcher. Parses route and delegates to handler.
; ============================================================================

fn @X402Server_handle_request(%0: ptr, %1: ptr) -> $X402Response {
  ; %0 = self: &mut X402Server
  ; %1 = request: &X402Request
entry:
  %2 = gep %1, 0                          ; &request.method
  %3 = load.str %2
  %4 = gep %1, 1                          ; &request.path
  %5 = load.str %4

  ; Log the request
  call @println_fmt("[x402] {} {}", %3, %5)

  ; Parse route
  %6 = call @parse_route(%3, %5)
  %7 = gep %6, 0                          ; route tag
  %8 = load.u8 %7

  ; Dispatch on tag
  %9 = const.u8 4                         ; Health
  %10 = icmp.eq %8, %9
  br_if %10, label @dispatch_health

  %11 = const.u8 0                        ; GetShake
  %12 = icmp.eq %8, %11
  br_if %12, label @dispatch_get_shake

  %13 = const.u8 1                        ; PostShake
  %14 = icmp.eq %8, %13
  br_if %14, label @dispatch_post_shake

  %15 = const.u8 2                        ; GetAgent
  %16 = icmp.eq %8, %15
  br_if %16, label @dispatch_get_agent

  %17 = const.u8 3                        ; ListJobs
  %18 = icmp.eq %8, %17
  br_if %18, label @dispatch_list_jobs

  br label @dispatch_not_found

dispatch_health:
  %19 = call @X402Server_handle_health(%0)
  ret %19

dispatch_get_shake:
  %20 = gep %6, 1                         ; payload: shake_id
  %21 = load.u256 %20
  %22 = call @X402Server_handle_get_shake(%0, %1, %21)
  ret %22

dispatch_post_shake:
  %23 = call @X402Server_handle_post_shake(%0, %1)
  ret %23

dispatch_get_agent:
  %24 = gep %6, 1                         ; payload: agent_address
  %25 = call @X402Server_handle_get_agent(%0, %1, %24)
  ret %25

dispatch_list_jobs:
  %26 = call @X402Server_handle_list_jobs(%0, %1)
  ret %26

dispatch_not_found:
  %27 = call @X402Response_not_found()
  ret %27
}

; ============================================================================
; FUNCTION: X402Server::handle_get_shake
; Payment-gated shake detail endpoint. Returns 402 if no proof.
; ============================================================================

fn @X402Server_handle_get_shake(%0: ptr, %1: ptr, %2: u256) -> $X402Response {
  ; %0 = self: &mut X402Server
  ; %1 = request: &X402Request
  ; %2 = shake_id: u256
entry:
  ; Check for payment proof
  %3 = call @X402Request_has_payment_proof(%1)
  %4 = const.u8 0
  %5 = icmp.eq %3, %4
  br_if %5, label @no_proof

  ; Parse proof
  %6 = call @X402Request_parse_payment_proof(%1)
  %7 = gep %6, 0                          ; result tag (0=Err, 1=Ok)
  %8 = load.u8 %7
  %9 = const.u8 0
  %10 = icmp.eq %8, %9
  br_if %10, label @bad_proof

  ; Validate chain ID
  %11 = gep %6, 1                         ; &proof
  %12 = gep %11, 1                        ; &proof.chain_id
  %13 = load.u64 %12
  %14 = gep %0, 2                         ; &self.config
  %15 = gep %14, 3                        ; &config.chain_id
  %16 = load.u64 %15
  %17 = icmp.ne %13, %16
  br_if %17, label @chain_mismatch

  ; Verify payment on-chain
  %18 = call @X402Server_verify_payment(%0, %11)
  %19 = gep %18, 0                        ; result tag
  %20 = load.u8 %19
  %21 = const.u8 1                        ; Ok tag
  %22 = icmp.ne %20, %21
  br_if %22, label @verify_failed

  ; Payment verified — build success response
  %23 = gep %11, 0                        ; &proof.tx_hash
  %24 = load.str %23
  %25 = call @format_shake_response(%2, %24)
  %26 = call @str_to_bytes(%25)
  %27 = call @X402Response_ok(%26.ptr, %26.len)
  %28 = call @X402Response_with_shake_id(%27, %2)
  ret %28

no_proof:
  ; Return 402 Payment Required
  %29 = gep %0, 3                         ; &self.payment_address
  %30 = gep %0, 4                         ; &self.default_amount
  %31 = load.u256 %30
  %32 = gep %0, 5                         ; &self.chain_name
  %33 = load.str %32
  %34 = gep %0, 6                         ; &self.protocol_version
  %35 = load.str %34
  %36 = call @X402Response_payment_required(%29, %31, %33, %35)
  ret %36

bad_proof:
  %37 = const.str "Invalid payment proof format"
  %38 = call @X402Response_bad_request(%37)
  ret %38

chain_mismatch:
  %39 = const.str "Chain ID mismatch"
  %40 = call @X402Response_bad_request(%39)
  ret %40

verify_failed:
  %41 = const.str "Payment verification failed"
  %42 = call @X402Response_internal_error(%41)
  ret %42
}

; ============================================================================
; FUNCTION: X402Server::handle_post_shake
; Payment-gated shake creation. Returns 402 if no escrow proof.
; ============================================================================

fn @X402Server_handle_post_shake(%0: ptr, %1: ptr) -> $X402Response {
  ; %0 = self: &mut X402Server
  ; %1 = request: &X402Request
entry:
  %2 = call @X402Request_has_payment_proof(%1)
  %3 = const.u8 0
  %4 = icmp.eq %2, %3
  br_if %4, label @no_proof

  ; Parse and validate proof (same pattern as handle_get_shake)
  %5 = call @X402Request_parse_payment_proof(%1)
  %6 = gep %5, 0
  %7 = load.u8 %6
  %8 = const.u8 0
  %9 = icmp.eq %7, %8
  br_if %9, label @bad_proof

  %10 = gep %5, 1                         ; &proof
  %11 = call @X402Server_verify_escrow_creation(%0, %10)
  %12 = gep %11, 0                        ; result tag
  %13 = load.u8 %12
  %14 = const.u8 1
  %15 = icmp.ne %13, %14
  br_if %15, label @verify_failed

  ; Extract shake_id from verification result
  %16 = gep %11, 1
  %17 = load.u256 %16
  %18 = gep %10, 0                        ; &proof.tx_hash
  %19 = load.str %18
  %20 = call @format_create_response(%17, %19)
  %21 = call @str_to_bytes(%20)
  %22 = call @X402Response_ok(%21.ptr, %21.len)
  %23 = call @X402Response_with_shake_id(%22, %17)
  ret %23

no_proof:
  ; Extract amount from body, fall back to default
  %24 = gep %1, 3                         ; &request.body
  %25 = call @X402Server_extract_amount_from_body(%0, %24)
  %26 = gep %25, 0                        ; option tag
  %27 = load.u8 %26
  %28 = const.u8 1                        ; Some
  %29 = icmp.eq %27, %28
  br_if %29, label @use_body_amount

  ; Use default amount
  %30 = gep %0, 4                         ; &self.default_amount
  %31 = load.u256 %30
  br label @emit_402

use_body_amount:
  %32 = gep %25, 1
  %33 = load.u256 %32
  br label @emit_402

emit_402:
  %34 = phi [%31, no_proof], [%33, use_body_amount]
  %35 = gep %0, 3                         ; &self.payment_address
  %36 = gep %0, 5                         ; &self.chain_name
  %37 = load.str %36
  %38 = gep %0, 6                         ; &self.protocol_version
  %39 = load.str %38
  %40 = call @X402Response_payment_required(%35, %34, %37, %39)
  ret %40

bad_proof:
  %41 = const.str "Invalid payment proof format"
  %42 = call @X402Response_bad_request(%41)
  ret %42

verify_failed:
  %43 = const.str "Escrow creation verification failed"
  %44 = call @X402Response_internal_error(%43)
  ret %44
}

; ============================================================================
; FUNCTION: X402Server::handle_get_agent
; Payment-gated passport query.
; ============================================================================

fn @X402Server_handle_get_agent(%0: ptr, %1: ptr, %2: ptr) -> $X402Response {
  ; %0 = self: &mut X402Server
  ; %1 = request: &X402Request
  ; %2 = agent_address: &Address
entry:
  %3 = call @X402Request_has_payment_proof(%1)
  %4 = const.u8 0
  %5 = icmp.eq %3, %4
  br_if %5, label @no_proof

  ; Validate proof and verify payment (elided for brevity — same pattern)
  %6 = call @X402Request_parse_payment_proof(%1)
  %7 = gep %6, 0
  %8 = load.u8 %7
  %9 = const.u8 0
  %10 = icmp.eq %8, %9
  br_if %10, label @bad_proof

  %11 = gep %6, 1                         ; &proof
  %12 = call @X402Server_verify_payment(%0, %11)
  %13 = gep %12, 0
  %14 = load.u8 %13
  %15 = const.u8 1
  %16 = icmp.ne %14, %15
  br_if %16, label @verify_failed

  ; Query registry for passport
  %17 = gep %0, 1                         ; &self.registry
  %18 = call @RegistryClient_get_passport(%17, %2)
  %19 = gep %18, 0                        ; result tag
  %20 = load.u8 %19
  %21 = const.u8 1
  %22 = icmp.ne %20, %21
  br_if %22, label @registry_error

  %23 = gep %18, 1                        ; &passport
  %24 = call @format_passport_response(%23)
  %25 = call @str_to_bytes(%24)
  %26 = call @X402Response_ok(%25.ptr, %25.len)
  ret %26

no_proof:
  %27 = gep %0, 3
  %28 = gep %0, 4
  %29 = load.u256 %28
  %30 = gep %0, 5
  %31 = load.str %30
  %32 = gep %0, 6
  %33 = load.str %32
  %34 = call @X402Response_payment_required(%27, %29, %31, %33)
  ret %34

bad_proof:
  %35 = const.str "Invalid payment proof format"
  %36 = call @X402Response_bad_request(%35)
  ret %36

verify_failed:
  %37 = const.str "Payment not confirmed on-chain"
  %38 = call @X402Response_bad_request(%37)
  ret %38

registry_error:
  %39 = const.str "Registry query failed"
  %40 = call @X402Response_internal_error(%39)
  ret %40
}

; ============================================================================
; FUNCTION: X402Server::handle_list_jobs
; Free endpoint — no payment gating.
; ============================================================================

fn @X402Server_handle_list_jobs(%0: ptr, %1: ptr) -> $X402Response {
  ; %0 = self: &mut X402Server
  ; %1 = request: &X402Request
entry:
  %2 = gep %0, 5                          ; &self.chain_name
  %3 = load.str %2
  %4 = gep %0, 6                          ; &self.protocol_version
  %5 = load.str %4
  %6 = call @format_jobs_response(%3, %5)
  %7 = call @str_to_bytes(%6)
  %8 = call @X402Response_ok(%7.ptr, %7.len)
  ret %8
}

; ============================================================================
; FUNCTION: X402Server::handle_health
; Free endpoint — returns server status.
; ============================================================================

fn @X402Server_handle_health(%0: ptr) -> $X402Response {
  ; %0 = self: &X402Server
entry:
  %1 = call @time_now_unix()
  %2 = gep %0, 5                          ; &self.chain_name
  %3 = load.str %2
  %4 = gep %0, 6                          ; &self.protocol_version
  %5 = load.str %4
  %6 = gep %0, 3                          ; &self.payment_address
  %7 = call @Address_to_hex(%6)
  %8 = call @format_health_response(%3, %5, %7, %1)
  %9 = call @str_to_bytes(%8)
  %10 = call @X402Response_ok(%9.ptr, %9.len)
  ret %10
}

; ============================================================================
; FUNCTION: X402Server::verify_payment
; Fetches transaction receipt via MIC@2 and validates status + block.
; ============================================================================

fn @X402Server_verify_payment(%0: ptr, %1: ptr) -> $Result_bool {
  ; %0 = self: &mut X402Server
  ; %1 = proof: &PaymentProof
entry:
  %2 = gep %1, 0                          ; &proof.tx_hash
  %3 = load.str %2

  ; Build MicOp::GetReceipt
  %4 = gep %0, 0                          ; &self.escrow
  %5 = gep %4, 1                          ; &escrow.transport
  %6 = alloc.MicOp
  %7 = const.u8 0x05                      ; GetReceipt opcode
  store.u8 %7, %6
  %8 = gep %6, 1
  store.str %3, %8

  ; Execute via MIC transport
  %9 = call @MicTransport_exec(%5, %6)
  %10 = gep %9, 0                         ; result tag
  %11 = load.u8 %10

  ; Check if result is Receipt variant
  %12 = const.u8 4                        ; Receipt tag in MicResult
  %13 = icmp.ne %11, %12
  br_if %13, label @unexpected_type

  ; Check receipt status
  %14 = gep %9, 1                         ; &receipt
  %15 = gep %14, 3                        ; &receipt.status
  %16 = load.u8 %15
  %17 = const.u8 0
  %18 = icmp.eq %16, %17
  br_if %18, label @tx_reverted

  ; Verified successfully
  %19 = alloc.Result_bool
  %20 = const.u8 1                        ; Ok tag
  store.u8 %20, %19
  %21 = const.u8 1                        ; true
  %22 = gep %19, 1
  store.u8 %21, %22
  %23 = load.Result_bool %19
  ret %23

tx_reverted:
  %24 = alloc.Result_bool
  %25 = const.u8 1                        ; Ok tag
  store.u8 %25, %24
  %26 = const.u8 0                        ; false
  %27 = gep %24, 1
  store.u8 %26, %27
  %28 = load.Result_bool %24
  ret %28

unexpected_type:
  %29 = alloc.Result_bool
  %30 = const.u8 0                        ; Err tag
  store.u8 %30, %29
  %31 = const.str "Unexpected response type"
  %32 = gep %29, 1
  store.str %31, %32
  %33 = load.Result_bool %29
  ret %33
}

; ============================================================================
; EXTERNAL FUNCTION DECLARATIONS
; Used by the above functions but defined in other MIC modules.
; ============================================================================

declare fn @str_clone(ptr) -> str
declare fn @str_len(str) -> u64
declare fn @str_eq(ptr, ptr) -> u8
declare fn @str_starts_with(str, ptr) -> u8
declare fn @str_substr(str, u64) -> str
declare fn @str_char_at(str, u64) -> u8
declare fn @str_to_bytes(str) -> $Vec_u8
declare fn @is_hex_char(u8) -> u8
declare fn @parse_u256(str) -> u256
declare fn @u256_to_string(u256) -> str
declare fn @println_fmt(ptr, ...)
declare fn @time_now_unix() -> u64
declare fn @Map_str_str_new() -> $Map_str_str
declare fn @Map_str_str_insert($Map_str_str, str, str)
declare fn @Map_str_str_contains_key(ptr, str) -> u8
declare fn @Map_str_str_get(ptr, str) -> $Option_str
declare fn @Vec_u8_new() -> $Vec_u8
declare fn @Vec_u8_from_raw(ptr, u64) -> $Vec_u8
declare fn @Address_zero() -> $Address
declare fn @Address_from_hex(str) -> $Address
declare fn @Address_to_hex(ptr) -> str
declare fn @MicTransport_exec(ptr, ptr) -> $MicResult
declare fn @RegistryClient_get_passport(ptr, ptr) -> $Result_AgentPassport
declare fn @X402Response_with_shake_id($X402Response, u256) -> $X402Response
declare fn @X402Response_bad_request(ptr) -> $X402Response
declare fn @X402Response_internal_error(ptr) -> $X402Response
declare fn @X402Server_extract_amount_from_body(ptr, ptr) -> $Option_u256
declare fn @X402Server_verify_escrow_creation(ptr, ptr) -> $Result_u256
declare fn @format_402_body(ptr, u256, ptr, ptr) -> str
declare fn @format_shake_response(u256, str) -> str
declare fn @format_create_response(u256, str) -> str
declare fn @format_passport_response(ptr) -> str
declare fn @format_jobs_response(str, str) -> str
declare fn @format_health_response(str, str, str, u64) -> str

}  ; end module @x402
