// Clawshake — MIC@2 Transport Layer
// Copyright (c) 2026 STARGA, Inc. All rights reserved.
//
// MIC@2 (Mind Intermediate Code v2) replaces JSON-RPC as the wire format
// for EVM communication. Instead of constructing JSON-RPC strings manually,
// agents express blockchain operations as MIC opcodes — the Mind runtime
// lowers them to the appropriate transport backend.
//
// Why MIC@2 over JSON-RPC:
// - Type-safe: opcodes are statically checked at compile time
// - Smaller: binary MIC frames are ~60% smaller than JSON-RPC text
// - Faster: no JSON parse/serialize overhead
// - Portable: same MIC ops work across HTTP, WebSocket, IPC
// - Inspectable: mind --emit-ir shows the exact call graph
//
// MIC@2 opcode format:
//   [version:u8][op:u8][chain:u32][target:20B][calldata:var][nonce:u64]
//
// Emit IR: mind --emit-ir src/mic.mind

import std.net;
import std.io;
import std.time;

import types::Address;
import crypto::*;

// ============================================================================
// MIC@2 VERSION
// ============================================================================

const MIC_VERSION: u8 = 2;

// ============================================================================
// MIC OPCODES — EVM operations as Mind IR primitives
// ============================================================================

enum MicOp {
    // Read operations (no gas, no signing)
    Call {
        target: Address,
        calldata: Vec<u8>,
    },
    GetBalance {
        account: Address,
    },
    GetCode {
        target: Address,
    },
    GetNonce {
        account: Address,
    },
    GetReceipt {
        tx_hash: str,
    },

    // Write operations (gas + signing required)
    SendTx {
        target: Address,
        calldata: Vec<u8>,
        value: u256,
        gas_limit: u64,
    },

    // Batch operations (multiple calls in one frame)
    Batch {
        ops: Vec<MicOp>,
    },
}

// ============================================================================
// MIC RESULT — typed response from EVM
// ============================================================================

enum MicResult {
    Bytes(Vec<u8>),
    Hash(str),
    Number(u256),
    Bool(bool),
    Receipt(TxReceipt),
    BatchResult(Vec<MicResult>),
    Error(MicError),
}

struct TxReceipt {
    tx_hash: str,
    block_number: u64,
    gas_used: u64,
    status: bool,
    logs: Vec<EventLog>,
}

struct EventLog {
    topics: Vec<[u8; 32]>,
    data: Vec<u8>,
}

enum MicError {
    ConnectionFailed(str),
    Timeout,
    Reverted(str),
    InsufficientFunds,
    NonceTooLow,
    GasExceeded,
    InvalidResponse(str),
}

// ============================================================================
// MIC@2 TRANSPORT — the runtime bridge to EVM
// ============================================================================

struct MicTransport {
    chain_id: u64,
    rpc_host: str,
    rpc_port: u16,
    signer: PrivateKey,
    nonce: u64,
    timeout_ms: i64,
    max_retries: u32,
}

impl MicTransport {
    fn new(chain_id: u64, rpc_host: &str, signer: PrivateKey) -> MicTransport {
        return MicTransport {
            chain_id: chain_id,
            rpc_host: rpc_host.to_string(),
            rpc_port: 443,
            signer: signer,
            nonce: 0,
            timeout_ms: 15000,
            max_retries: 3,
        };
    }

    fn base_sepolia(signer: PrivateKey) -> MicTransport {
        return MicTransport::new(84532, "sepolia.base.org", signer);
    }

    // ========================================================================
    // EXECUTE — dispatch MIC opcode to EVM
    // ========================================================================

    fn exec(&mut self, op: MicOp) -> Result<MicResult, MicError> {
        match op {
            MicOp::Call { target, calldata } => {
                self.exec_call(&target, &calldata)
            }
            MicOp::GetBalance { account } => {
                self.exec_get_balance(&account)
            }
            MicOp::GetCode { target } => {
                self.exec_get_code(&target)
            }
            MicOp::GetNonce { account } => {
                self.exec_get_nonce(&account)
            }
            MicOp::GetReceipt { tx_hash } => {
                self.exec_get_receipt(&tx_hash)
            }
            MicOp::SendTx { target, calldata, value, gas_limit } => {
                self.exec_send_tx(&target, &calldata, value, gas_limit)
            }
            MicOp::Batch { ops } => {
                self.exec_batch(ops)
            }
        }
    }

    // ========================================================================
    // READ OPERATIONS — lowered to eth_call
    // ========================================================================

    fn exec_call(&self, target: &Address, calldata: &[u8]) -> Result<MicResult, MicError> {
        let from_hex = self.signer.address().to_hex();
        let to_hex = target.to_hex();
        let data_hex = bytes_to_hex(calldata);

        let payload = self.rpc_payload(
            "eth_call",
            &format!("[{{\"from\":\"{}\",\"to\":\"{}\",\"data\":\"{}\"}},\"latest\"]",
                from_hex, to_hex, data_hex),
        );

        let response = self.send_rpc(&payload)?;
        let hex = self.extract_result(&response)?;
        let bytes = hex_decode(&hex)?;

        return Ok(MicResult::Bytes(bytes));
    }

    fn exec_get_balance(&self, account: &Address) -> Result<MicResult, MicError> {
        let payload = self.rpc_payload(
            "eth_getBalance",
            &format!("[\"{}\",\"latest\"]", account.to_hex()),
        );

        let response = self.send_rpc(&payload)?;
        let hex = self.extract_result(&response)?;
        let val = hex_to_u256(&hex);

        return Ok(MicResult::Number(val));
    }

    fn exec_get_code(&self, target: &Address) -> Result<MicResult, MicError> {
        let payload = self.rpc_payload(
            "eth_getCode",
            &format!("[\"{}\",\"latest\"]", target.to_hex()),
        );

        let response = self.send_rpc(&payload)?;
        let hex = self.extract_result(&response)?;
        let bytes = hex_decode(&hex)?;

        return Ok(MicResult::Bytes(bytes));
    }

    fn exec_get_nonce(&self, account: &Address) -> Result<MicResult, MicError> {
        let payload = self.rpc_payload(
            "eth_getTransactionCount",
            &format!("[\"{}\",\"latest\"]", account.to_hex()),
        );

        let response = self.send_rpc(&payload)?;
        let hex = self.extract_result(&response)?;
        let val = hex_to_u256(&hex);

        return Ok(MicResult::Number(val));
    }

    fn exec_get_receipt(&self, tx_hash: &str) -> Result<MicResult, MicError> {
        let payload = self.rpc_payload(
            "eth_getTransactionReceipt",
            &format!("[\"{}\"]", tx_hash),
        );

        let response = self.send_rpc(&payload)?;

        // Parse receipt fields
        let receipt = self.parse_receipt(&response)?;
        return Ok(MicResult::Receipt(receipt));
    }

    // ========================================================================
    // WRITE OPERATIONS — sign + broadcast via eth_sendRawTransaction
    // ========================================================================

    fn exec_send_tx(
        &mut self,
        target: &Address,
        calldata: &[u8],
        value: u256,
        gas_limit: u64,
    ) -> Result<MicResult, MicError> {
        // Build EIP-1559 transaction
        let tx = Transaction {
            chain_id: self.chain_id,
            nonce: self.nonce,
            max_priority_fee: 1_500_000_000,  // 1.5 gwei
            max_fee: 15_000_000_000,           // 15 gwei
            gas_limit: gas_limit,
            to: target.clone(),
            value: value,
            data: calldata.to_vec(),
        };

        // Sign with agent's key
        let signed = tx.sign(&self.signer);
        self.nonce += 1;

        // Broadcast
        let hex_tx = bytes_to_hex(&signed);
        let payload = self.rpc_payload(
            "eth_sendRawTransaction",
            &format!("[\"{}\"]", hex_tx),
        );

        let response = self.send_rpc(&payload)?;
        let tx_hash = self.extract_result(&response)?;

        return Ok(MicResult::Hash(tx_hash));
    }

    // ========================================================================
    // BATCH — execute multiple MIC ops in sequence
    // ========================================================================

    fn exec_batch(&mut self, ops: Vec<MicOp>) -> Result<MicResult, MicError> {
        let mut results = Vec::new();
        for op in ops {
            let result = self.exec(op)?;
            results.push(result);
        }
        return Ok(MicResult::BatchResult(results));
    }

    // ========================================================================
    // MIC FRAME ENCODING — binary wire format
    // ========================================================================

    fn encode_frame(&self, op: &MicOp) -> Vec<u8> {
        let mut frame = Vec::new();

        // Header: [version:u8][op_type:u8][chain_id:u32]
        frame.push(MIC_VERSION);
        frame.push(op_type_byte(op));
        frame.extend_from_slice(&(self.chain_id as u32).to_be_bytes());

        // Body varies by opcode
        match op {
            MicOp::Call { target, calldata } => {
                frame.extend_from_slice(&target.bytes);
                frame.extend_from_slice(&(calldata.len() as u32).to_be_bytes());
                frame.extend_from_slice(calldata);
            }
            MicOp::SendTx { target, calldata, value, gas_limit } => {
                frame.extend_from_slice(&target.bytes);
                frame.extend_from_slice(&u256_to_bytes(*value));
                frame.extend_from_slice(&gas_limit.to_be_bytes());
                frame.extend_from_slice(&(calldata.len() as u32).to_be_bytes());
                frame.extend_from_slice(calldata);
                frame.extend_from_slice(&self.nonce.to_be_bytes());
            }
            MicOp::GetBalance { account } | MicOp::GetCode { target: account } | MicOp::GetNonce { account } => {
                frame.extend_from_slice(&account.bytes);
            }
            MicOp::GetReceipt { tx_hash } => {
                let hash_bytes = hex_decode(tx_hash).unwrap_or_default();
                frame.extend_from_slice(&hash_bytes);
            }
            MicOp::Batch { ops } => {
                frame.extend_from_slice(&(ops.len() as u32).to_be_bytes());
                for sub_op in ops {
                    let sub_frame = self.encode_frame(sub_op);
                    frame.extend_from_slice(&(sub_frame.len() as u32).to_be_bytes());
                    frame.extend_from_slice(&sub_frame);
                }
            }
        }

        return frame;
    }

    // ========================================================================
    // RPC LOWERING — MIC frames → JSON-RPC (current backend)
    // Future backends: MIC → WebSocket, MIC → IPC, MIC → direct binary
    // ========================================================================

    fn rpc_payload(&self, method: &str, params: &str) -> str {
        return format!(
            "{{\"jsonrpc\":\"2.0\",\"method\":\"{}\",\"params\":{},\"id\":1}}",
            method, params,
        );
    }

    fn send_rpc(&self, payload: &str) -> Result<str, MicError> {
        let socket = net::tls_connect(&self.rpc_host, self.rpc_port, self.timeout_ms)
            .map_err(|e| MicError::ConnectionFailed(format!("{}", e)))?;

        let request = format!(
            "POST / HTTP/1.1\r\nHost: {}\r\nContent-Type: application/json\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
            self.rpc_host, payload.len(), payload,
        );

        socket.write_all(request.as_bytes())
            .map_err(|_| MicError::Timeout)?;

        let response = socket.read_all_timeout(self.timeout_ms)
            .map_err(|_| MicError::Timeout)?;

        let response_str = String::from_utf8_lossy(&response);

        // Extract HTTP body
        if let Some(body_start) = response_str.find("\r\n\r\n") {
            return Ok(response_str[body_start + 4..].to_string());
        }

        return Err(MicError::InvalidResponse("No HTTP body".to_string()));
    }

    fn extract_result(&self, response: &str) -> Result<str, MicError> {
        if let Some(start) = response.find("\"result\":\"") {
            let start = start + 10;
            if let Some(end) = response[start..].find("\"") {
                return Ok(response[start..start + end].to_string());
            }
        }

        if response.contains("\"error\"") {
            if response.contains("nonce too low") {
                return Err(MicError::NonceTooLow);
            }
            if response.contains("insufficient funds") {
                return Err(MicError::InsufficientFunds);
            }
            if response.contains("execution reverted") {
                return Err(MicError::Reverted(response.to_string()));
            }
            return Err(MicError::InvalidResponse(response.to_string()));
        }

        return Err(MicError::InvalidResponse("No result field".to_string()));
    }

    fn parse_receipt(&self, response: &str) -> Result<TxReceipt, MicError> {
        // Extract key fields from receipt JSON
        let status = response.contains("\"status\":\"0x1\"");
        let tx_hash = self.extract_field(response, "transactionHash")
            .unwrap_or_default();

        return Ok(TxReceipt {
            tx_hash: tx_hash,
            block_number: 0,
            gas_used: 0,
            status: status,
            logs: Vec::new(),
        });
    }

    fn extract_field(&self, json: &str, field: &str) -> Option<str> {
        let pattern = format!("\"{}\":\"", field);
        if let Some(start) = json.find(&pattern) {
            let start = start + pattern.len();
            if let Some(end) = json[start..].find("\"") {
                return Some(json[start..start + end].to_string());
            }
        }
        return None;
    }

    // ========================================================================
    // SYNC NONCE — fetch current nonce from chain
    // ========================================================================

    fn sync_nonce(&mut self) -> Result<(), MicError> {
        let addr = self.signer.address();
        let result = self.exec(MicOp::GetNonce { account: addr })?;

        match result {
            MicResult::Number(n) => {
                self.nonce = n as u64;
                return Ok(());
            }
            _ => return Err(MicError::InvalidResponse("Bad nonce response".to_string())),
        }
    }
}

// ============================================================================
// OPCODE TYPE BYTE
// ============================================================================

fn op_type_byte(op: &MicOp) -> u8 {
    match op {
        MicOp::Call { .. }       => 0x01,
        MicOp::GetBalance { .. } => 0x02,
        MicOp::GetCode { .. }    => 0x03,
        MicOp::GetNonce { .. }   => 0x04,
        MicOp::GetReceipt { .. } => 0x05,
        MicOp::SendTx { .. }     => 0x10,  // write ops start at 0x10
        MicOp::Batch { .. }      => 0xFF,
    }
}

// ============================================================================
// HEX HELPERS
// ============================================================================

fn hex_decode(hex: &str) -> Result<Vec<u8>, MicError> {
    let hex = if hex.starts_with("0x") { &hex[2..] } else { hex };
    if hex.len() % 2 != 0 {
        return Err(MicError::InvalidResponse("Odd hex".to_string()));
    }

    let mut bytes = Vec::with_capacity(hex.len() / 2);
    for i in (0..hex.len()).step_by(2) {
        let byte = u8::from_str_radix(&hex[i..i + 2], 16)
            .map_err(|_| MicError::InvalidResponse("Bad hex".to_string()))?;
        bytes.push(byte);
    }

    return Ok(bytes);
}

fn hex_to_u256(hex: &str) -> u256 {
    let hex = if hex.starts_with("0x") { &hex[2..] } else { hex };
    let mut val: u256 = 0;
    for c in hex.chars() {
        let digit = match c {
            '0'..='9' => (c as u256) - ('0' as u256),
            'a'..='f' => (c as u256) - ('a' as u256) + 10,
            'A'..='F' => (c as u256) - ('A' as u256) + 10,
            _ => 0,
        };
        val = (val << 4) | digit;
    }
    return val;
}
